# 1. 개념

- 제너레이터(generator)는 여러 가지 값을 한 번에 만들어낼 수 있는 특별한 함수이다.

- 제너레이터는 이터레이터를 생성하는 특별한 종류의 함수이며, 이터레이터 프로토콜을 내부적으로 따르고있다.

  - [참고] 이터레이터 프로토콜: **next()** 메서드와 **done**, **value** 속성을 가진 객체를 반환하는 것

- 제너레이터는 이터레이터 프로토콜을 준수하면서 `yield` 키워드를 이용해 값을 반환하고 함수의 실행을 중지시킨다.

- 따라서 제너레이터를 호출하면 이터레이터가 반환되고, 이터레이터를 통해 제너레이터 함수를 실행하고 값을 받아올 수 있다.

  - ✨ 제너레이터는 **값을 만들어 내는 함수**이고, 이터레이터는 **그 값을 차례로 받아오는 도구**이다.

<br /><br />

# 2. 예시

```javascript
// 1부터 3까지의 숫자를 만들어주는 제너레이터 함수
function* numberGenerator() {
  yield 1;
  yield 2;
  yield 3;
}

// 위 함수를 호출하면 이터레이터를 얻게 된다.
// 따라서 그 이터레이터를 사용해 값을 하나씩 받아올 수 있다.
const iterator = numberGenerator();

console.log(iterator.next().value); // 1
console.log(iterator.next().value); // 2
console.log(iterator.next().value); // 3
console.log(iterator.next().value); // undefined
```

- 제너레이터 함수는 값을 필요로 할 때마다 생성해주고, `yield` 키워드를 통해 함수의 실행을 중지시킨다.

- 그래서 반복문 없이도 필요한 값들을 차례로 만들어낼 수 있다.

<br /><br />

# 3. 제너레이터를 사용하는 이유

1. **지연 계산**

    - 제너레이터는 필요한 순간에만 값을 계산하고 반환할 수 있다. 따라서 메모리와 성능을 절약할 수 있다.

    - 예를 들어 제너레이터를 사용해 큰 데이터 집합 생성 시, 모든 데이터를 미리 계산하여 메모리에 저장하지 않고 필요한 순간에만 생성할 수 있다. <br />

2. **비동기 프로그래밍**

    - 제너레이터는 비동기적인 작업을 쉽게 다룰 수 있다.

    - 제너레이터 사용 시 비동기 작업을 동기적으로 보이도록 제어할 수 있고, 비동기 코드를 더 읽기 쉽고 관리하기 쉽게 만들 수 있다. <br />

3. **무한한 시퀀스 생성**

    - 제너레이터 사용 시 무한한 시퀀스를 생성할 수 있다. 예를 들어 피보나치 수열이나 무한 수열을 생성할 때 유용하다.

    - 무한한 시퀀스 생성 시 일반적인 반복문을 사용할 수 없지만, 제너레이터를 사용하면 필요에 따라 값을 계속 생성할 수 있다. <br />

4. **상태 유지**

    - 제너레이터는 함수의 실행 상태를 유지할 수 있다.

    - 이전 호출에서 실행되었던 지점부터 함수를 다시 시작할 수 있으며, 이는 함수가 여러 번 호출될 때 상태를 유지하는데 유용하다. <br />

5. **코드의 간결성과 가독성**

    - 제너레이터 사용 시 반복문과 비동기 코드를 더 간결하고 가독성 있게 작성할 수 있다.

    - 제너레이터는 제어 흐름을 명시적으로 표현할 수 있고, 코드를 선형적으로 유지할 수 있다.

<br />

### [참고] 제너레이터를 이용한 비동기 작업?

- 제너레이터를 사용해 비동기 작업을 처리하는 방법은 일반적으로 다음과 같이 Promise와 함께 사용한다.

- 이를 **코루틴(co-routine)** 이라고도 한다.

- 방법

  1. 비동기 작업을 수행할 함수를 제너레이터 함수로 작성한다.

      - 이 함수는 비동기 작업을 수행하고 결과를 반환하는데, 작업이 완료될 때까지 함수 실행을 일시 중지한다.

      - 작업이 완료되면 결과를 반환한다.

  2. 제너레이터 함수 내에서 비동기 작업을 실행할 때는 Promise를 사용한다.

      - Promise를 사용해 비동기 작업을 시작하고, 작업이 완료될 때 resolve된 값을 yield한다.

  3. 제너레이터 함수를 호출하고 반환된 이터레이터를 사용해 비동기 작업의 결과를 받아온다.

      - 이터레이터의 next() 메서드를 호출해 제너레이터 함수의 실행을 진행하고, yeid된 값을 받아온다.

- 예시

  ```javascript
  function* asyncTaskGenerator() {
    const result = yield new Promise((resolve, reject) => {
      setTimeout(() => {
        resolve('비동기 작업 완료!');
      }, 2000);
    });
    return result;
  }

  const iterator = asyncTaskGenerator();
  const promise = iterator.next().value;

  promise.then((result) => {
    console.log(result); // '비동기 작업 완료!'
  });
  ```
  
  - 위 함수는 제너레이터 함수 asyncTaskGenerator를 정의하고 그 안에서 비동기 작업을 수행하는 Promise를 yield한다.

  - 그리고 이터레이터를 생성하고, 그 안에서 제너레이터 함수의 실행을 시작한다.

  - 비동기 작업이 완료되면 결과를 받아온다.

- 위의 함수가 다른 방법에 가지는 주요 이점

  1. **가독성**

      - 비동기 작업의 흐름이 명확하게 표현된다.

      - Promise 체인을 작성하는 대신 제너레이터 함수 내에서 비동기 작업을 수행하고 결과를 받아올 때까지 함수 실행을 일시 중지할 수 있다.

  2. **동기적인 코드와 유사함**

      - 제너레이터 함수 내에서 yield 키워드를 사용해 비동기 작업을 일시 중지시키고, 작업이 완료되면 결과를 반환한다.

      - 이렇게 하면 코드가 동기적으로 보이고, 비동기 작업의 순서를 명확하게 제어할 수 있다.

  3. **상태 유지**

      - 제너레이터 함수는 상태를 유지할 수 있다.

      - 이전 호출에서 실행되었던 지점부터 함수를 다시 시작할 수 있으며, 이는 함수가 여러 번 호출될 때 상태를 유지하는 데 유용한다.

  4. **효율적인 리소스 관리**

      - Promise를 직접 사용하는 것보다 더 효율적으로 리소스를 관리할 수 있다.

      - 제너레이터 함수는 필요한 순간에만 비동기 작업을 수행하고 결과를 반환하므로 리소스 사용을 최적화할 수 있다.